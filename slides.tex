\documentclass{beamer}

\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{listings}
\usetheme{bjeldbak}
\input{haskell-settings}

\title{¡Hola, Haskell!}
\author{Fernanda Andrade}
\institute{Stack Builders}
\date{28 y 29 de abril de 2016}

\logo{\includegraphics[scale=0.10]{img/stackbuilders-logo.png}}

\begin{document}
  {%
    \setbeamertemplate{headline}{}
    \frame{\titlepage}
  }


%------------------------------------------------------------------------------------------------------------

\section{Introducción}

\begin{frame}[fragile]
  \frametitle{¡Hola, mundo!}

\begin{lstlisting}
holaHaskell :: IO ()
holaHaskell = putStrLn "Hola, Haskell"
\end{lstlisting}


\end{frame}

%------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
  \frametitle{Haskell}


  \begin{columns}[T]
    \begin{column}{.54\textwidth}
      \begin{block}

         \begin{figure}
           \includegraphics[width=0.9\textwidth]{img/haskell.png}
         \end{figure}

         \begin{center}
           \url{https://www.haskell.org/}
         \end{center}

      \end{block}
    \end{column}

    \begin{column}{.55\textwidth}

      \begin{block}{}

        \begin{itemize}
	  \item Funcional
          \item Puro
	    \begin{itemize}
              \item Inmutabilidad
              \item Sin efectos secundarios
              \item Transparencia referencial
    \end{itemize} 
	 \item Evaluación perezosa
	  \item Tipificación estática
	  \item Funciones de orden superior
        \end{itemize} 

      \end{block}
    \end{column}
  \end{columns}

\end{frame}

%------------------------------------------------------------------------------------------------------------

\section{Funcional}

\begin{frame}[fragile]
  \frametitle{Haskell es funcional}
  \framesubtitle{No es imperativo}

Factorial en C: 

\begin{lstlisting}[language=c]
int factorial(int n) {
    int result = 1;
    for (int i = 1; i <= n; ++i)
        result *= i;
    return result;
}
\end{lstlisting}


\end{frame}

%------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
  \frametitle{Haskell es funcional}
  \framesubtitle{No es imperativo}

Factorial en Haskell: 

\begin{lstlisting}

factorial 0 = 1
factorial n = n * factorial (n-1)
\end{lstlisting}


\end{frame}

%------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
  \frametitle{Haskell es funcional}
  \framesubtitle{No es imperativo}

Factorial en Haskell: 

\begin{lstlisting}
factorial :: Int -> Int
factorial 0 = 1
factorial n = n * factorial (n-1)
\end{lstlisting}


\end{frame}

%------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
  \frametitle{Haskell es funcional}
  \framesubtitle{Evaluación de expresiones}

\begin{figure}
  \includegraphics[width=0.4\textwidth]{img/function.png}
\end{figure}


\end{frame}


%------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
  \frametitle{Haskell es funcional}
  \framesubtitle{Evaluación de expresiones}


\begin{verbatim}
  f(x) = x + x
\end{verbatim}

\end{frame}

%------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
  \frametitle{Haskell es funcional}
  \framesubtitle{Evaluación de expresiones}

\begin{verbatim}
  f(x) = x + x
\end{verbatim}
\vspace{-0.5cm}
\color{blue} 
\begin{verbatim}
  f(2) = 2 + 2
  f(2) = 4 
\end{verbatim}

\end{frame}

%------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
  \frametitle{Haskell es funcional}
  \framesubtitle{Evaluación de expresiones}

\begin{verbatim}
  f(x) = x + x
\end{verbatim}
\vspace{-0.5cm}
\begin{verbatim}
  f(2) = 2 + 2
  f(2) = 4 
\end{verbatim}
\vspace{-0.8cm}
\color{blue} 
\begin{verbatim}
  f(5) = 5 + 5
  f(5) = 10 
\end{verbatim}

\end{frame}

%------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
  \frametitle{Haskell es funcional}
  \framesubtitle{Evaluación de expresiones}

\begin{lstlisting}
  doble :: Int -> Int 
  doble n = n + n
\end{lstlisting}


\end{frame}

%------------------------------------------------------------------------------------------------------------

\section{Puro}

\begin{frame}[fragile]
  \frametitle{Haskell es puro}
  \framesubtitle{Inmutabilidad}

Sumar números de 1 a n en C: 

\begin{lstlisting}[language=c]
int sum(int n){
	int result = 0;
	for(int i=1; i<=n; i++)
	  result += i
	return result
}
\end{lstlisting}

\end{frame}

%------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
  \frametitle{Haskell es puro}
  \framesubtitle{Inmutabilidad}

En caso de n = 3

\begin{verbatim}
  i = 1
\end{verbatim} 
\vspace{-0.8cm}
\color{blue} 
\begin{verbatim}
  total = 1
\end{verbatim}

\end{frame}

%------------------------------------------------------------------------------------------------------------


\begin{frame}[fragile]
  \frametitle{Haskell es puro}
  \framesubtitle{Inmutabilidad}

En caso de n = 3

\begin{verbatim}
  i = 1
  total = 1
  i = 2
\end{verbatim}
\vspace{-0.8cm}
\color{blue} 
\begin{verbatim}
  total = 3
\end{verbatim}

\end{frame}

%------------------------------------------------------------------------------------------------------------


\begin{frame}[fragile]
  \frametitle{Haskell es puro}
  \framesubtitle{Inmutabilidad}

En caso de n = 3

\begin{verbatim}
  i = 1
  total = 1
  i = 2
  total = 3 
  i = 3
\end{verbatim}
\vspace{-0.8cm}
\color{blue} 
\begin{verbatim}
  total = 6
\end{verbatim}

\end{frame}

%------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
  \frametitle{Haskell es puro}
  \framesubtitle{Inmutabilidad}

Sumar números de 1 a n en Haskell: 

\begin{lstlisting}
sum [1.. n]
\end{lstlisting}

\end{frame}

%------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
  \frametitle{Haskell es puro}
  \framesubtitle{Inmutabilidad}

Sumar números de 1 a n en Haskell: 

\begin{lstlisting}
sum :: Num a => [a] -> a
sum [] = 0
sum (x : xs) = x + sum xs
\end{lstlisting}

\vspace{0.3cm}

\begin{itemize}
\item Variables y estructuras de datos son inmutables.
\end{itemize}

\end{frame}

%------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
  \frametitle{Haskell no tiene efectos secundarios}

En C:

\begin{lstlisting}[language=c]
int main() {
    printf("Hola, mundo.");
    return(0);
}
\end{lstlisting}

\end{frame}

%------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
  \frametitle{Haskell no tiene efectos secundarios}

En Haskell: 

\begin{lstlisting}
count :: [a] -> Int
\end{lstlisting}

\vspace{0.3cm}

\begin{itemize}
\item Funciones sólo pueden calcular y retornar valores. 
\item Funciones garantizan integridad.
\end{itemize}

\end{frame}

%------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
  \frametitle{Haskell es puro}
  \framesubtitle{Transparencia referencial}

En c: 

\vspace{0.3cm}

\begin{lstlisting}[language=c,basicstyle=\tiny]
int global = 5;

int suma (int n){
  return (n + global);
}

int main(){
  int resultado;
  
  // resultado = 6
  resultado = suma(1); 
  
  global = 0;
  
  // resultado = 1
  resultado = suma(1); 

}
\end{lstlisting}

\end{frame}

%------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
  \frametitle{Haskell es puro}
  \framesubtitle{Transparencia referencial}

En Haskell: 

\begin{lstlisting}
x :: Int
x = 5

suma :: Int -> Int
suma n = n + x
\end{lstlisting}


\end{frame}

%------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
  \frametitle{Haskell es puro}
  \framesubtitle{Transparencia referencial}

\begin{lstlisting}[numbers=none, backgroundcolor=\color{lightgray}, keywordstyle=\color{black}]
> suma 1
6
> suma 1
6
\end{lstlisting}

\begin{itemize}
\item Si una función es llamada dos veces con los mismos parámetros, obtendremos siempre el mismo resultado.
\end{itemize}

\end{frame}

%------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
  \frametitle{Haskell es puro}
  \framesubtitle{Transparencia referencial}
  
\begin{lstlisting}
x :: Int
x = 5

suma :: Int -> Int
suma n = n + x

x = 0
\end{lstlisting}

\vspace{0.3cm}

{\color{red}
\begin{verbatim}
    Multiple declarations of ‘x’
    Declared at: suma.hs:2:1
                 suma.hs:7:1
Failed, modules loaded: none.

\end{verbatim}}

\end{frame}

%------------------------------------------------------------------------------------------------------------

\section{Evaluación perezosa}

\begin{frame}[fragile]
  \frametitle{Haskell tiene evaluación perezosa}

\begin{lstlisting}
square :: Int -> Int
square x = x * x
\end{lstlisting}

\begin{lstlisting}[numbers=none, backgroundcolor=\color{lightgray}, keywordstyle=\color{black}]
> square (1 + 2)
=> (1 + 2) * (1 + 2)
=> 3 * (1+2)
=> 3 * 3
=> 9
\end{lstlisting}

\vspace{0.3cm}

\begin{itemize}
\item Haskell no calculará resultados hasta que se vea realmente forzado a hacerlo. 
\end{itemize}

\end{frame}

%------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
  \frametitle{Haskell tiene evaluación perezosa}

Primeros 5 números de una lista infinita

\begin{lstlisting}[numbers=none, backgroundcolor=\color{lightgray}, keywordstyle=\color{black}]
> take 5 [1..]
[1,2,3,4,5]
\end{lstlisting}

\vspace{0.3cm}

\begin{itemize}
\item Es posible trabajar con estructura de datos infinitos. 
\end{itemize}

\end{frame}

%------------------------------------------------------------------------------------------------------------

\section{Tipificado estáticamente}

\begin{frame}[fragile]
  \frametitle{Haskell es un lenguaje tipificado estáticamente}

\begin{lstlisting}
printString :: String -> IO ()
printString word = putStrLn word
\end{lstlisting}

\end{frame}


%------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
  \frametitle{Haskell es un lenguaje tipificado estáticamente}

\begin{lstlisting}[numbers=none, backgroundcolor=\color{lightgray}, keywordstyle=\color{black}]
> printString 5
\end{lstlisting}

{\color{red} 
\begin{verbatim}
   <interactive>:18:13:
    No instance for (Num String) arising from the 
    literal ‘5’
    In the first argument of ‘printString’, namely 
    ‘5’
    In the expression: printString 5
    In an equation for ‘it’: it = printString 5
\end{verbatim}}

\vspace{0.3cm}

\begin{itemize}
\item Haskell verifica que el tipo de dato declarado coincide con el tipo inferido (en tiempo de compilación). 
\end{itemize}

\end{frame}

%------------------------------------------------------------------------------------------------------------

\section{Funciones de orden superior}

\begin{frame}[fragile]
  \frametitle{Funciones de orden superior}
  \framesubtitle{map}

\begin{lstlisting}
map :: (a -> b) -> [a] -> [b]
map _ [] = []
map f (x:xs) = f x : map f xs
\end{lstlisting}

\vspace{0.3cm}

\begin{itemize}
\item Funciones pueden tomar funciones como parámetros y devolver funciones como resultado.
\end{itemize}

\end{frame}

%------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
  \frametitle{Funciones de orden superior}
  \framesubtitle{map}

\begin{lstlisting}[numbers=none, backgroundcolor=\color{lightgray}, keywordstyle=\color{black}]
> map (+3) [0,1,2,3,4,5]
[3,4,5,6,7,8]
\end{lstlisting}


\end{frame}

%------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
  \frametitle{Funciones de orden superior}
  \framesubtitle{filter}

\begin{lstlisting}
filter :: (a -> Bool) -> [a] -> [a]
filter _ [] = []
filter p (x:xs)
    | p x       = x : filter p xs
    | otherwise = filter p xs
\end{lstlisting}

\end{frame}

%------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
  \frametitle{Funciones de orden superior}
  \framesubtitle{filter}


\begin{lstlisting}[numbers=none, backgroundcolor=\color{lightgray}, keywordstyle=\color{black}]
> filter even [1,2,3,4,5,6]
[2,4,6]
\end{lstlisting}

\vspace{0.3cm}

\begin{lstlisting}[numbers=none, backgroundcolor=\color{lightgray}, keywordstyle=\color{black}]
> filter (>3) [1,2,3,4,5,6]
[4,5,6]
\end{lstlisting}

\end{frame}


\end{document}
